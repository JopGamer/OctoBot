import { setTimeout } from 'node:timers';
import { MessageActionRow, MessageButton, MessageEmbed } from 'discord.js';
import { Listener } from 'gcommands';
import { fetch, FormData } from 'undici';
import config from '../config.js';
import { sectotime } from '../utils/sectotime.js';

new Listener({
  name: 'messageCreate',
  event: 'messageCreate',
  run: async message => {
    if (!config.discord.userIds.find(u => u === message.author.id) || message.channel.id !== config.discord.channelId) return;
    if (
      message.attachments.size === 0 ||
      !message.attachments.first().name.includes('.gcode') ||
      !message.attachments.first().contentType === 'text/plain; charset=utf-8'
    ) return;

    const buffer = await (await fetch(message.attachments.first().url)).text();

    const text = buffer.toString();
    const info = text.split('\n').slice(0, 3);

    let type = '';
    if (info[0] === ';FLAVOR:Marlin\r') type = 'Cura-Marlin';
    else if (info[0].includes === '; generated by PrusaSlicer') type = 'PrusaSlicer';

    const psu = await (
      await fetch(`${config.octoprint.url}/api/plugin/psucontrol`, {
        method: 'POST',
        headers: {
          'X-Api-Key': config.octoprint.token,
        },
        body: JSON.stringify({
          command: 'getPSUState',
        }),
      })
    ).json();

    let timeout = 0;

    if (!psu.isPSUOn) {
      timeout = 3000;
      fetch(`${config.octoprint.url}/api/plugin/psucontrol`, {
        method: 'POST',
        headers: {
          'X-Api-Key': config.octoprint.token,
        },
        body: JSON.parse({
          command: 'turnPSUOn',
        }),
      });
    }

    setTimeout(async () => {
      const embed = new MessageEmbed().setColor('BLUE').setDescription(`**File is uploading...**`);

      const msg = await message.reply({
        embeds: [embed],
      });

      const embed2 = new MessageEmbed().setColor('BLUE');

      if (type === 'Cura-Marlin') {
        embed2.setDescription(
          [
            `**File has been Uploaded!**`,
            ` `,
            `Print Duration: **${sectotime(parseFloat(info[1].split(':')[1]))}**`,
            `Filament: **${info[2].split(':')[1]}**`,
          ].join('\n'),
        );
      } else {
        embed2.setDescription(`**File has been Uploaded!**`);
      }

      const button = new MessageButton().setLabel('Print').setStyle('SUCCESS')
.setCustomId('print');

      const row1 = new MessageActionRow().setComponents(button);

      const formdata = new FormData();
      formdata.append('file', text, message.attachments.first().name);
      formdata.append('select', 'true');

      await fetch(`${config.octoprint.url}/api/files/local`, {
        method: 'POST',
        headers: {
          'X-Api-Key': config.octoprint.token,
        },
        body: formdata,
      });

      msg.edit({
        embeds: [embed2],
        components: [row1],
      });

      const filter = i => i.user.id === message.author.id && i.isButton() && i.channel.id === message.channel.id;
      const messageComponent = await msg.channel.awaitMessageComponent({ filter, time: 45 * 1000 }).catch(() => {});
      messageComponent.deferReply().catch(() => {});

      if (!messageComponent.customId || messageComponent.customId !== 'print') {
        button.setDisabled();
        row1.setComponents(button);

        msg.edit({
          embeds: [embed2],
          components: [row1],
        });
        return;
      }

      await fetch(`${config.octoprint.url}/api/job`, {
        method: 'POST',
        headers: {
          'X-Api-Key': config.octoprint.token,
        },
        body: JSON.stringify({
          command: 'start',
        }),
      }).catch(e => {
        messageComponent.editReply({
          content: `${config.emojis.error} - Error: \`${e}\``,
        });
        console.log(e);
      });

      const embed3 = new MessageEmbed()
        .setColor('GREEN')
        .setDescription(`Printing of file **${message.attachments.first().name}** has been started!`);

      messageComponent.editReply({
        embeds: [embed3],
      });
    }, timeout);
  },
});
